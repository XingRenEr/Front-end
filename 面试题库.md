面试题库
---

* [x] [23:58，47:11，面试干货视频(hr 面以及技术面)](https://www.bilibili.com/video/BV16441137QB?from=search&seid=16025366212027778585)  
* [x] [面试题](https://zhuanlan.zhihu.com/p/101986056)  

![前端面试常考知识点](面试题库_files/1.png)  

## 一 JS 基础
**知识点**  
- [变量类型]
	- [值类型和引用类型]
		- [堆和栈]
	- [JS的数据类型、判断](#1.1)
	- [==和===]
- [原型与原型链]
	- [原型和原型链定义](#1.6)
	- [继承写法](#1.7)
- [作用域和闭包]
	- [闭包是什么](#1.4)
	- [this]
		- [call bind apply]
		- [指向问题]
	- [作用域和作用域链](#1.3)
- [ES6/ES7]
	- [箭头函数]
	- [Module]
	- [Promise]
		- [async 和 await]
		- [generator 函数]
	- [Class]
	- [Set 和 Map]
	- [let 和 const]
	- [proxy]
- [异步]
	- [同步 vs 异步]
	- [异步和单线程]
		- [event loop]
	- [前端异步的场景]
	- [web work]
	- [AMD CMD commonJS]
	- [async 和 defer]
- [API]
	- [数组]
		- [改变原数组的API]
		- [不改变原数组的API]
	- [对象](#1.5)
		- [浅拷贝](#1.2)
		- [深拷贝](#1.2)
	- [window]
		- [location]
		- [navigate]
	- [ajax 和 fetch]
		- [readyState 4个状态]
	- [WebSocket]
		- [轮询和长轮询]
	- [存储]
		- [cookie]
		- [localStorage]
		- [sessionStorage]
- [跨域]
	- [jsonp]
	- [window.name]
	- [document.domain]
	- [代理]
	- [postMessage]
	- [cors]
- [动画]
	- [setimeout]
	- [requestanimationframe]
- [事件]
	- [DOM0事件]
	- [DOM2事件]
		- [事件传播机制]
	- [冒泡机制]
	- [事件代理]


### <a id="1.1"></a>1.1 数据类型及判断  
**数据类型**  
![数据类型](Javascript/基础/images/数据类型.png)  
**判断类型**  
![数据类型判断](Javascript/基础/images/3.png)  
- `typeof(variable)`  
```js
typeof NaN; // number
typeof 10n; // bigint
typeof Symbol(); // symbol
```
- `variable instanceof Array`  
`instanceof` 就是原型链的查找过程。`instanceof` 能判断的有：  
 - `Function`  
 - `Array`  
 - `Date`  
 - `RegExp`  
 - `Error`  
- `variable.constructor == Array`  
`constructor` 能判断的有：除了 `undefined` 和 `null`  
问题：`constructor` 的属性是可以被修改的，可能导致检测出的结果不正确。  
- `Object.prototype.toString.call(variable)` 通用  
将它的结果 `result.slice(8, -1)`  
- `Array.isArray(variable)` 针对 Array 类型  

### <a id="1.2"></a>1.2 深浅拷贝  
**浅拷贝**  
```js
Object.assign() //es6
```
栗子  
```js
var obj={aa:1,b:{item:'45'}};
var newObj=Object.assign({},obj);
obj.aa=2;
obj.b.item='kk';
console.log(newObj.aa); //1
console.log(newObj.b.item); //kk
```
**深拷贝**  
原生API  
```js
JSON.parse(JSON.stringify(obj))
```
**常见问题**  
1. 什么是深拷贝？什么是浅拷贝？  
浅拷贝：Object.assign 会合并对象生成一个新对象。如果原对象的属性是普通类型改变之后新对象不会改变，如果是引用类型改变后新对象也会改变，所以 Object.assign 实际上还是浅拷贝。  
2. 手撕代码：深拷贝  
```js
function cloneDeep(source) {
  if (!isObject(source)) return source; // 非对象返回自身
  var target = Array.isArray(source) ? [] : {};
  for (var key in source) {
    if (source.hasOwnProperty(i)) {
      if (isObject(source[key])) {
        target[key] = cloneDeep(source[key]); // 注意这里
      } else {
        target[key] = source[key];
      }
    }
  }
  return target;
}
function isObject(obj) {
  return typeof obj === 'object' && obj != null;
}
```

### <a id="1.3"></a>1.3 变量声明提升、作用域与作用域链  
**变量声明提升**  
- 在JavaScript 中，函数声明（function aa(){}）与变量声明（var）被JavaScript 引擎隐式地提升到当前作用域的顶部。  
- 函数声明的优先级高于变量，如果变量名跟函数名相同且未赋值，则函数声明会覆盖变量声明  
- 声明语句中的赋值部分并不会被提升，只有变量的名称被提升  

**作用域与作用域链**  
- 在JavaScript 中，作用域为function(){}内的区域，称为函数作用域。  
- 函数的嵌套形成作用域的层级关系。  
- 当函数执行时，从当前作用域开始搜，没有找到的变量，会向上层作用域查找，直至全局函数，这就是作用域链。  
- 全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节  

### <a id="1.4"></a>1.4 闭包  
原理：作用域链。  
定义：比函数F 内部有一个函数G，函数G 可以访问到函数F 中的变量，那么函数G 就是闭包。  
```js
function F() {
  let a = 1
  window.G = function() {
    console.log(a)
  }
}
F()
G() // 1
```

### <a id="1.5"></a>1.5 创建对象  
**创建对象的方式**  
1. 对象字面量 `{}`  
2. new 一个构造函数  
3. new 一个内置对象 `new Object()`  
4. `Object.create()`  
```js
var test = Object.create({x:1})
```

**常见问题**  
1. new Object() 、Object.create()、{}，这三种方式创建对象有什么区别  
Object.create(null) 创建的对象是一个空对象，在该对象上没有继承 Object.prototype 原型链上的属性或者方法，例如：toString()，hasOwnProperty()等方法  
2. 如何实现一个类  
构造函数法  
```js
function P(name, age) {
  this.name = name;
  this.age = age;
}
P.prototype.sal = function() {}
var pel = new P("jj", 1);
pel.sell()
```
ES6 语法糖 class  
```js
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  toString() {
    return '(' + this.x + ', ' + this.y + ')';
  }
}
var point = new Point(2, 3);
```


### <a id="1.6"></a>1.6 原型和原型链  
任何一个类（函数）都有**原型对象**  
函数上有一个 prototype 属性，指向**原型对象**，通过它可以访问原型对象  
函数的实列可以直接访问**原型对象**(因为实列上有 proto 指向构造函数的原型对象)  
原型对象至少有两个属性（constructor，proto）。constructor 指向函数本身，proto 指向**父类原型对象**，形成**原型链**。  

### <a id="1.7"></a>1.7 手撕代码：继承  
希望属性放在构造函数中(引用类型在原型中共享会有问题)，方法放在原型中(重用)  




* [x] [30分钟学会前端模块化开发](https://www.cnblogs.com/best/p/10076782.html)  

**常见问题**  
1. 手撕代码：call bind apply  
2. 箭头函数与普通函数的区别  
3. 手撕代码：Promise  
4. 什么是同步？什么是异步？什么是单线程？  
5. async 和 defer 区别  
8. window.navigate  
用于客户端检测  
9. 手撕代码：原生 Ajax  
10. Ajax 和 Fetch 区别  
11. WebSocket 兼容  
轮询、长轮询  
12. 轮询、长轮询区别、优缺点  
13. cookie、localStorage、sessionStorage 区别、应用场景  
14. 动画是用什么实现的  

## 二 CSS 基础
**知识点**  
- 盒模型
- BFC
- float
	- 请除浮动
- flex
- 兼容
- position(五个属性值)
- 行内元素和块级元素
- sass，less语法
- 动画
- 居中布局

**常见问题**  
1. 考察 BFC 的规则  
2. 清除浮动的原理  
3. 行内元素和块级元素转化  

## 三 JS 框架
**知识点**  
- View层
	- React
		- 生命周期
		- prop 和 state
		- 虚拟 dom
			- diff 原理
		- redux
		- 组件间的通信（父子/兄弟/爷孙）
		- react-router 的原理
			- hash 模式和 history 模式
		- Mixin
			- react 高阶组件
			- render props
	- Vue
		- 双向数据绑定
			- defineProperty 和 proxy 区别
		- 生命周期
		- prop 和 state
		- Mixin
		- 虚拟 dom
			- diff 原理
		- 组件间的通信（父子/兄弟/爷孙）
		- Vuex（状态管理）
		- vue 指令（v-model...）
- 移动端
	- React Native
	- Weex
	- lonic
	- Flutter
	- PWA
		- service worker

**常见问题**  
1. React 生命周期  
一般不考单个组件的生命周期  
eg：父组件中有一个子组件，子组件中又有一个子组件；父组件中还有一个同级的子组件。它们的生命周期是怎么发生的  
2. React redux 是什么，用途  
3. React react-router hash 模式和 history 模式的区别、优缺点  
4. React Mixin 为什么被弃用？替代方法是什么？  
5. React react 高阶组件和渲染 props 的优缺点、应用场景  
6. Vue 实现双向数据绑定有哪几种方法？defineProperty(Vue2) 和 proxy(Vue3) 的区别？为什么要用 proxy 代替 defineProperty？  
7. 移动端框架的实现原理  
8. 移动端 JS 如何与 React Native 进行通信  
9. 移动端框架的优缺点  
10. 移动端 PWA 特性有哪些  
11. 移动端 PWA service worker 的生命周期  

## 四 网络
**知识点**  
- 协议
	- HTTP
		- HTTP1.0、1.1、2.0
			- 常见状态码(知道的越多越好)
				- 200、304...
		- 缓存
			- 强缓存
			- 协商缓存
		- 常见字段
			- content-type、origin...
	- DNS
	- TCP
		- 三次握手、四次挥手
	- UDP
	- HTTPS
		- 加密过程
- 七层模型

**常见问题**  
1. HTTP1.0、1.1、2.0 的区别、新增的字段及作用  
2. TCP、UDP 的区别  
3. HTTP 与 HTTPS 的区别  

## 五 性能优化
**知识点**  
- 加载优化
- 图片优化
- css 优化
- 脚本优化
- 渲染优化


1. 图片优化  
若图片允许使用 WebP 格式，用 WebP 格式代替 JPEG  
2. 脚本优化  
避免重绘、重排  
3. 渲染优化  
用 CSS 的三个属性加速 GPU 渲染  

**常见问题**  

## 六 设计模式
**知识点**  
- 观察者模式  

- 单例模式  

- 命令模式  

- 装饰者模式  

- 策略模式  

- 工厂模式  

- 适配器模式  

- 组合模式  

- 代理模式  


**常见问题**  
1. 你知道的设计模式有哪些  
2. 优缺点  
3. 应用场景  
4. 几种设计模式的比较  
> 结合 1 2 3  
5. 观察者模式手撕代码——Vue 的双向数据绑定  

## 七 前端安全
**知识点**  
- XSS  
- SQL 注入  
- CSRF  

**常见问题**  
1. 你知道前端有什么安全的问题吗？
2. 如何去防范

## 八 操作系统
**知识点**  
- 进程和线程
	- 进程间通信和线程间通信
- 死锁
	- 避免的方法
- CPU 调度算法

**常见问题**  
1. 进程和线程分别是什么、它们的区别  
2. 产生死锁有哪几个条件  
3. CPU 调度算法有哪些  
先到先服务(FCFS)、最短作业优先(SJF)  
4. CPU 调度算法的应用场景、优缺点  


## 九 数据结构
**知识点**  
- 链表
	- 单向链表
		- 判断环以及环入口
	- 双向链表
	- 循环链表
- 各种树
	- b+树
	- b-树
	- b*树
	- 红黑树
	- 二叉树
		- 满二叉树
		- 平衡二叉树
		- 哈夫曼树
		- 完全二叉树
		- 二叉查找树
- 栈
- 队列
- 哈希表
	- 哈希构造方法
	- 哈希冲突
- 堆
- 哈夫曼编码

**常见问题**  
1. 堆的实现、堆的应用  


## 十 算法
**知识点**  
- 排序
	- 冒泡排序
	- 选择排序
	- 希尔排序
	- 归并排序
	- 快速排序
	- 堆排序
	- 插入排序
	- 桶排序
	- 基数排序
	- 计数排序
- 动态规划
- 递归，尾递归，尾调用
- 查找
	- 二分查找
- 时间复杂度的计算


* [x] [十大排序算法](https://github.com/shenzekun/Sorts)  

**常见问题**  
1. 手撕代码：会写十大排序算法  
2. 了解十大排序算法的最好、最坏、平均时间复杂度  
3. 尾递归、尾调用的区别是什么  

